<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Citation animée – Arzankia</title>

<link href="https://fonts.googleapis.com/css2?family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet">
<style>
  :root{
    --or:#ffd674;
    --ivoire:#fff8e6;
    --txtshadow: 0 0 6px rgba(255,214,116,.28), 0 2px 4px rgba(0,0,0,.55);
  }

  body{
    margin:0;
    min-height:100svh;
    display:grid; place-items:center;
    background: url('fond_monde_terre.png') center/cover fixed no-repeat, #12081a;
    color: var(--ivoire);
    font-family: Georgia, serif;
  }

  /* ===== Scène de citation ===== */
  .quote-stage{
    position:relative;
    width:min(960px, 92vw);
    padding: min(6vw, 48px) min(4vw, 32px);
    /* juste pour respirer, pas de cadre */
  }

  /* Ligne finale (sert de gabarit) */
  .quote-line{
    font-family: "IM Fell English", Georgia, serif;
    font-size: clamp(1.15rem, 2.8vw, 1.6rem);
    line-height: 1.9;
    letter-spacing:.2px;
    text-align:center;
    text-shadow: var(--txtshadow);
    margin:0;
    opacity:0;         /* elle reste invisible, mais mesurable */
    visibility:hidden; /* garde la place, utile pour mesurer */
  }
  .quote-line .guil{
    color: var(--or);
    font-size: 1.4em;
    text-shadow: 0 0 12px rgba(255,214,116,.35);
  }

  /* Calque qui recevra les mots animés en absolu */
  .quote-actors{
    position:absolute; inset:0;
    pointer-events:none;
  }

  /* Style des mots volants */
  .word{
    position:absolute;
    white-space:pre;
    font-family: "IM Fell English", Georgia, serif;
    font-size: clamp(1.15rem, 2.8vw, 1.6rem);
    line-height: 1.9;
    text-shadow: var(--txtshadow);
    will-change: transform, opacity, filter;
    transform: translate(var(--x,0px), var(--y,0px)) scale(.96);
    opacity: 0;
    filter: blur(2px);
    transition:
      transform .85s cubic-bezier(.17,.84,.23,1.08),
      opacity   .85s ease-out,
      filter    .85s ease-out;
  }

  /* Souffle lumineux qui passe une fois la phrase complète */
  .shine{
    position:absolute; inset:-20% -10%;
    background: linear-gradient(100deg, transparent 45%, rgba(255,255,255,.18) 50%, transparent 55%);
    transform: translateX(-70%) rotate(4deg);
    pointer-events:none;
    opacity:0;
  }
  .shine.play{
    animation: shine-pass .55s ease-out forwards;
  }
  @keyframes shine-pass{
    0%   { opacity:.0; transform: translateX(-70%) rotate(4deg); }
    10%  { opacity:.8; }
    100% { opacity:0;  transform: translateX(70%) rotate(4deg); }
  }

  /* Scintillement doux des mots (après feux) */
  .twinkle{
    animation: twinkle .6s ease-in-out;
  }
  @keyframes twinkle{
    0%   { text-shadow: var(--txtshadow); filter:none; }
    40%  { text-shadow:
              0 0 8px rgba(255,214,116,.65),
              0 0 18px rgba(255,214,116,.35),
              0 2px 4px rgba(0,0,0,.55);
           transform: translateY(-1px); }
    100% { text-shadow: var(--txtshadow); transform:none; }
  }

  /* Canvas feux d’artifice */
  canvas#fw{
    position:fixed; inset:0; z-index:0; pointer-events:none;
  }

  /* Accessibilité : réduire les mouvements */
  @media (prefers-reduced-motion: reduce){
    .word{ transition:none; filter:none; }
  }
</style>
</head>
<body>

  <!-- Scène -->
  <section class="quote-stage" id="quoteStage">
    <!-- Gabarit de phrase (invisible) -->
    <p class="quote-line" id="quoteLine">
      <span class="guil">«</span>
      Ici, les notes dansent, les couleurs vibrent, et d’étranges créatures laissent exprimer leur talent à la lumière…
      <span class="guil">»</span>
    </p>

    <!-- Calque des acteurs (mots animés) -->
    <div class="quote-actors" id="quoteActors" aria-hidden="true"></div>

    <!-- Souffle lumineux -->
    <div class="shine" id="shine" aria-hidden="true"></div>
  </section>

  <!-- Feux d'artifice (déclenchés à la fin) -->
  <canvas id="fw" aria-hidden="true"></canvas>

<script>
(function(){
  const prefersReduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const stage = document.getElementById('quoteStage');
  const line  = document.getElementById('quoteLine');
  const actors= document.getElementById('quoteActors');
  const shine = document.getElementById('shine');

  // 1) Découpe en mots (en conservant espaces et ponctuation)
  const textContent = line.textContent.trim();
  const tokens = textContent.split(/(\s+)/); // garde les espaces comme tokens

  // 2) Construire des spans dans la ligne (pour mesurer)
  line.innerHTML = '';
  const measSpans = [];
  tokens.forEach(t=>{
    const s = document.createElement('span');
    s.textContent = t;
    line.appendChild(s);
    measSpans.push(s);
  });

  // 3) Construire les clones "acteurs" positionnés en absolu
  const actorSpans = [];
  const rectStage = stage.getBoundingClientRect();
  measSpans.forEach((m,i)=>{
    const r = m.getBoundingClientRect();
    const a = document.createElement('span');
    a.className = 'word';
    a.textContent = m.textContent;

    // Position cible relative au calque acteurs
    const targetX = r.left - rectStage.left;
    const targetY = r.top  - rectStage.top;

    // Start depuis le bas (hors écran)
    const startY  = Math.max(window.innerHeight - rectStage.top + 40, rectStage.height + 80);

    a.style.left = '0px';
    a.style.top  = '0px';
    a.style.setProperty('--x', `${targetX}px`);
    a.style.setProperty('--y', `${startY}px`);

    // On place d'abord en bas (translateY start), puis on anime vers (targetX, targetY)
    // Pour animer, on passera --y à targetY avec un délai.
    actors.appendChild(a);
    actorSpans.push({el:a, targetX, targetY});
  });

  // 4) Lancer l'animation d'arrivée des mots
  function launchWords(){
    const baseDelay = 90; // ms
    const jitter    = 60; // ms
    let arrived = 0;

    actorSpans.forEach((w, i)=>{
      const delay = i*baseDelay + Math.random()*jitter;

      // position de départ (bas)
      w.el.style.transform = `translate(${w.targetX}px, ${parseFloat(getComputedStyle(w.el).getPropertyValue('--y'))}px) scale(.96)`;

      setTimeout(()=>{
        w.el.style.opacity = '1';
        w.el.style.filter  = 'blur(0px)';
        // vers la cible
        w.el.style.transform = `translate(${w.targetX}px, ${w.targetY}px)`;
      }, delay);

      w.el.addEventListener('transitionend', (ev)=>{
        if (ev.propertyName === 'transform'){
          arrived++;
          if (arrived === actorSpans.length){
            onSentenceComplete();
          }
        }
      }, { once:false });
    });
  }

  // 5) Quand la phrase est complète : souffle -> feux -> twinkles
  function onSentenceComplete(){
    // Souffle
    shine.classList.add('play');

    // Au bout du souffle (~550ms), lancer les feux
    setTimeout(()=>{
      startFireworks();
      startTwinkles();
    }, 560);
  }

  // 6) Scintillement aléatoire
  let twinkleTimer = null;
  function startTwinkles(){
    if (prefersReduce) return; // pas d'effets
    const pool = actorSpans.filter(w => w.el.textContent.trim().length); // pas les espaces
    twinkleTimer = setInterval(()=>{
      const n = Math.min(2, 1 + (Math.random()<0.3 ? 1:0)); // 1 ou 2 mots parfois
      for (let i=0;i<n;i++){
        const w = pool[Math.floor(Math.random()*pool.length)];
        w.el.classList.add('twinkle');
        setTimeout(()=> w.el.classList.remove('twinkle'), 620);
      }
    }, 1200);
  }

  // 7) Feux d’artifice minimalistes, déclenchés sur commande
  const canvas = document.getElementById('fw');
  const ctx = canvas.getContext('2d');
  let W=0,H=0, dpr=1, fwRunning=false, particles=[], rockets=[], fwStopAt=0;

  function resize(){
    dpr = Math.max(1, window.devicePixelRatio||1);
    W = canvas.width  = Math.floor(innerWidth*dpr);
    H = canvas.height = Math.floor(innerHeight*dpr);
    canvas.style.width  = innerWidth+'px';
    canvas.style.height = innerHeight+'px';
  }
  addEventListener('resize', resize, {passive:true}); resize();

  function startFireworks(){
    if (prefersReduce) return;
    fwRunning = true;
    fwStopAt = performance.now() + 7000; // 7s
    loop();
    scheduleRockets();
  }

  function scheduleRockets(){
    if (!fwRunning) return;
    spawnRocket();
    setTimeout(scheduleRockets, 400 + Math.random()*700);
  }

  function spawnRocket(){
    const x  = (0.12 + Math.random()*0.76)*W;
    const y  = H*0.98;
    const vy = -(1.2 + Math.random()*0.6)*dpr;
    rockets.push({x,y, vx:(Math.random()-.5)*0.5*dpr, vy, life:0, max: 50+Math.random()*40, hue: Math.random()*360});
  }

  function explode(x,y,hue){
    const n = 120 + (Math.random()*100|0);
    for (let i=0;i<n;i++){
      const a = (i/n)*Math.PI*2;
      const sp= (1+Math.random()*1.2)*dpr;
      particles.push({
        x,y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp*(Math.random()<0.5?0.8:1),
        a: 1,
        hue: (hue + (i%12)*4)%360,
        decay: 0.985 - Math.random()*0.004
      });
    }
  }

  function loop(ts){
    if (!fwRunning && particles.length===0 && rockets.length===0) return;

    ctx.globalCompositeOperation='destination-out';
    ctx.fillStyle='rgba(0,0,0,0.14)';
    ctx.fillRect(0,0,W,H);
    ctx.globalCompositeOperation='lighter';

    // rockets
    for (let i=rockets.length-1;i>=0;i--){
      const r = rockets[i];
      r.life++;
      r.vy += 0.006*dpr;
      r.x += r.vx; r.y += r.vy;

      // trail
      ctx.globalAlpha=1;
      ctx.fillStyle = `hsl(${r.hue} 95% 70%)`;
      ctx.beginPath(); ctx.arc(r.x, r.y, 1.2*dpr, 0, Math.PI*2); ctx.fill();

      if (r.vy > -0.15*dpr || r.life>r.max){
        explode(r.x, r.y, r.hue);
        rockets.splice(i,1);
      }
    }

    // particles
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.vy += 0.006*dpr;
      p.vx *= 0.996; p.vy *= 0.996;
      const px=p.x, py=p.y; p.x+=p.vx; p.y+=p.vy;
      p.a *= p.decay;
      if (p.a<0.04){ particles.splice(i,1); continue; }

      ctx.globalAlpha=p.a;
      ctx.strokeStyle=`hsl(${p.hue} 90% 58%)`;
      ctx.lineWidth=1.1*dpr;
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(px,py); ctx.stroke();
    }

    if (fwRunning && performance.now()>fwStopAt){
      fwRunning=false;
      // laisse s'éteindre naturellement
      setTimeout(()=>{ ctx.clearRect(0,0,W,H); }, 1200);
    }

    requestAnimationFrame(loop);
  }

  // Lancement
  function start(){
    if (prefersReduce){
      // Version soft : fade in direct, pas de feux
      actors.innerHTML = '';
      line.style.opacity = 1;
      line.style.visibility = 'visible';
      return;
    }
    launchWords();
  }

  // Attendre le rendu initial pour des positions propres
  requestAnimationFrame(()=> requestAnimationFrame(start));
})();
</script>
</body>
</html>

